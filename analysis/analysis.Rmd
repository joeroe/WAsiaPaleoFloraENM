---
title: "Palaeodistribution of crop progenitors and wild foods in the Southern Levant"
author: "Joe Roe"
format: html
bibliography: references.bib
---

```{r dependencies}
library("dplyr")
library("fs")
library("furrr")
library("ggplot2")
library("ggspatial")
library("gt")
library("here")
library("parsnip")
library("purrr")
library("ranger")
library("readr")
library("rgbif")
library("rpaleoclim")
library("sf")
library("stars")
library("stringr")
library("tibble")
library("tidyr")

library("BadiaPaleoFloraENM") # this package, install with devtools::install()
```

```{r parallelise}
# Several parts of this analysis are processing- and memory-intensive.
# You may need to adjust the futures strategy specified here to fit your 
# computational resources. See ?future::plan for options.
plan("multisession")
```

```{r definitions}
latlong <- 4326
utm37n <- 32637

w_asia <- st_bbox(c(xmin = 30, xmax = 50, ymin = 25, ymax = 40), crs = 4326)
s_levant <- st_bbox(c(xmin = 34, xmax = 39, ymin = 29, ymax = 34), crs = 4326)
```

## Introduction

## Background

## Methods and materials

```{r data-basemap}
# Turn off s2 while we deal with Natural Earth's dodgy geometries
use_s2 <- sf_use_s2(FALSE)

ne_countries <- read_sf(raw_data("ne"), "ne_10m_admin_0_countries")

ne_lakes <- read_sf(raw_data("ne"), "ne_10m_lakes") |> 
  st_geometry() |>
  st_crop(buffer_bbox(w_asia, 10)) |>
  st_union()

ne_ocean <- read_sf(raw_data("ne"), "ne_10m_ocean") |>
  st_geometry() |>
  st_crop(buffer_bbox(w_asia, 10)) |>
  st_union()

ne_land <- read_sf(raw_data("ne"), "ne_10m_land") |> 
  st_geometry() |>
  st_crop(buffer_bbox(w_asia, 10)) |>
  st_difference(ne_ocean) |>
  st_difference(ne_lakes) |>
  st_union()

s_levant_land <- st_intersection(st_as_sfc(s_levant), ne_land)

# Restore previous setting of s2
sf_use_s2(use_s2)
```

### Taxa and occurrence data

To generate the list of taxa modelled in this study, we ...

* Taxa present at more than three Neolithic sites, according to the database of our previous study [@ArranzOtaeguiRoe2023]
* Identified at least to species (and matchable to the GBIF Backbone Taxonomy)
* Have at least 100 occurrences in West Asia (meeting the criteria below) in the GBIF database
* Excluded domestic species, replacing them with their wild progenitor, where known and present in the GBIF database

We also considered the number modern occurrences available for each taxon.
ENMs are known to have reasonable predictive power even with small training samples (i.e. less than a hundred observations, [@StockwellPeterson2002; @HernandezEtAl2006; @WiszEtAl2008]).

```{r data-neolithic-flora}
neolithic_flora <- read_tsv(raw_data("swasia_neolithic_flora.tsv"))

# Rename some columns for clarity
neolithic_flora <- rename(neolithic_flora,
                          taxon_group = "taxon", taxon = "taxon_detail")

# Assign to archaeological periods
periods <- tribble(
  ~period,             ~agriculture,                          ~start_bp, ~end_bp,
  "Late Epipal.",      "Foraging",                            15000,     11700,
  "PPNA",              "Pre-domestication cultivation",       11700,     10700,
  "EPPNB",             "Cultivation of domesticated species", 10700,     10200,
  "MPPNB",             "Cultivation of domesticated species", 10200,     9500,
  "LPPNB/C",           "Agriculture",                         9500,      8500,
  "Pottery Neolithic", "Agriculture",                         8500,      6500,
  "Chalcolithic",      "Agriculture",                         6500,      5000,
)

neolithic <- c("PPNA", "EPPNB", "MPPNB", "LPPNB/C", "Pottery Neolithic")

neolithic_flora <- mutate(neolithic_flora,
                          age_mid = age_end + ((age_start - age_end) / 2),
                          period = cut(-age_mid, 
                                       breaks = -c(periods$start_bp, 0), 
                                       labels = periods$period,
                                       ordered_result = TRUE)
)

# Assemblage statistics
neolithic_flora |> 
  distinct(site_name, phase_code, period) |> 
  filter(period %in% neolithic) |> 
  nrow() ->
  n_assemb_neolithic

neolithic_flora |> 
  filter(period %in% neolithic) |> 
  distinct(site_name) |> 
  nrow() ->
  n_site_neolithic
```

```{r data-taxa}
neolithic_flora |>
  # group_by(taxon_group) |>
  # mutate(taxon = list(unique(taxon))) |>
  filter(period %in% neolithic) |>
  group_by(taxon) |>
  summarise(
    n_present = length(unique(phase_code)),
    p_present = n_present / n_assemb_neolithic,
    .groups = "drop"
  ) |>
  filter(n_present > 2) ->
  taxa
```

```{r taxa-names}
# Normalise species names and match to the GBIF Backbone Taxonomy
# Excluding taxa not identified to species
taxa |>
  filter(!str_ends(taxon, "sp.")) |>
  mutate(
    taxon = case_match(taxon,
                       "Vicia narbonense" ~ "Vicia narbonensis", # N=3
                       "Triticum aestivocompactum" ~ "Triticum aestivum compactum", # N=3
                       "Heliotropium persicum" ~ "Moltkia angustifolia", # N=2
                       "Lens orientalis" ~ "Vicia orientalis", # N=2
                       "Scirpus tabernaemontani" ~ "Schoenoplectus tabernaemontani", # N=2
                       "Stipa capensis" ~ "Stipa dregeana", # N=2
                       .default = taxon),
    taxon_original = taxon,
    taxon = map_chr(taxon, gbif_accepted_name)
  ) ->
  taxa

# TODO: trim to wild types?
# taxa |>
#   drop_na(taxon) |>
#   mutate(
#     taxon = str_remove(taxon, " sp."),
#     taxon_original = taxon,
#     taxon = map_chr(taxon, gbif_accepted_name)
#   ) |>
#   drop_na(taxon) |> # Drop names that couldn't be matched to GBIF
#   filter(!taxon %in% domesticates) |>
#   group_by(taxon_group) |>
#   mutate(
#     genus = str_extract(taxon, "[^\\s]+"),
#     is_genus = genus == taxon,
#     genus_in_group = genus %in% taxon
#   ) |>
#   filter(is_genus | !genus_in_group) |> # Drop redundant taxons
#   distinct(taxon_group, taxon, n_present, p_present) ->
#   taxa
```

```{r taxa-domesticates}
# Recode domesticates as their wild progenitors.
# Add other wild progenitors of wheats
taxa |> 
  mutate(taxon = case_match(
    taxon,
    "Cicer arietinum" ~ "Cicer reticulatum",
    "Hordeum vulgare" ~ "Hordeum spontaneum",
    "Vicia lens" ~ "Vicia orientalis",
    "Linum usitatissimum" ~ "Linum bienne",
    "Triticum aestivum" ~ "Triticum turgidum dicoccum",
    "Triticum dicoccoides" ~ "Triticum turgidum dicoccum",
    "Triticum turgidum durum" ~ "Triticum turgidum dicoccum",
    "Triticum monococcum" ~ "Triticum monococcum aegilopoides",
    .default = taxon
  )) |>
  bind_rows(tibble(taxon = c("Triticum urartu", "Aegilops speltoides", 
                             "Aegilops tauschii"))) ->
  taxa
```

```{r taxa-occ-count}
taxa |>
  group_by(taxon) |>
  summarise(
    taxon_original = list(c(taxon_original)),
    n_present = max(n_present), # TODO: be more precise?
    p_present = max(p_present)
    ) |>
  mutate(n_occ = map_dbl(taxon, \(x) occ_count(scientificName = x, 
                                               hasCoordinate = TRUE, 
                                               hasGeospatialIssue = FALSE,
                                               geometry = bbox_wkt(w_asia)))) ->
  taxa
```

```{r tbl-taxa-occ-count}
#| tbl-cap: "Taxonomic groups modelled in this study."
# TODO: add to caption:
# - with presence in Neolithic sites in West Asia, out of the X sites included in Y
# - with number of reliably-georeferenced occurrences in West Asia recorded in GBIF
# TODO: add count of species included?
taxa |>
  mutate(
    taxon_detail = map_chr(taxon_original, paste, collapse = ", "),
    taxon_detail = if_else(taxon == taxon_detail, NA_character_, taxon_detail),
    include = n_occ > 50
  ) |>
  select(-taxon_original) |>
  group_by(include) |>
  arrange(-n_present) |>
  gt() |>
  cols_merge(
    c(taxon, taxon_detail),
    rows = !is.na(taxon_detail),
    pattern = "{1}<br><small>(incl. {2})</small>"
  ) |>
  fmt_percent(p_present, decimals = 0) |>
  cols_merge_n_pct(n_present, p_present) |>
  tab_style(cell_text(style = "italic"), cells_body(taxon))
```

Occurrence data was obtained from GBIF using the GBIF occurrence API.
This deals with synonyms etc. (using the GBIF Backbone Taxonomy as a standard), so e.g. retrieving data for "Bolboschoenus" includes all species and subspecies, including specimens described as *Bolboschoenus sp.*, *Bolboschoenus maritimus* and *Scirpus maritimus*.

```{r data-occ}
taxa <- filter(taxa, n_occ > 50)
gbif_data <- function(scientificName, ...) {
  gbif_data <- rgbif::occ_data(scientificName = scientificName, ...)
  gbif_data$data
}

gbif_path <- here::here("analysis", "data", "derived_data", "gbif")

#taxa <- c("Triticum dicoccoides" = "Triticum dicoccoides",
#          "Triticum urartu" = "Triticum urartu",
#          "Hordeum spontaneum" = "Hordeum spontaneum",
#          "Vicia orientalis" = "Vicia orientalis", # AKA Lens (culinaris) orientalis
#          "Bolboshoenus spp." = "Bolboschoenus")

# TODO: maybe first with occ_count first?

# Get occurrence data from GBIF
# Including only records with coordinates and no recorded issues with geospatial
#   data.
taxa |>
  select(taxon, taxon) |>
  deframe() |> # Extract as named vector
  future_map(gbif_data, hasCoordinate = TRUE, hasGeospatialIssue = FALSE, 
      geometry = w_asia, limit = 100000) |>
  list_rbind(names_to = "taxon") ->
  occ

# Exclude:
# * Coordinate uncertainty of 5 km or more (≈2.5 mins)
# * Fossil occurrences
occ |>
  filter(coordinateUncertaintyInMeters < 5000 | is.na(coordinateUncertaintyInMeters)) |>
  filter(basisOfRecord != c("FOSSIL_SPECIMEN")) ->
  occ

# Remove redundant observations of the same taxon in the same place
occ |>
  group_by(taxon) |>
  distinct(decimalLongitude, decimalLatitude, .keep_all = TRUE) |>
  ungroup() ->
  occ

# TODO: temp dump -- remove
save(occ, file = "big_occ.Rdata")

# Drop unneeded columns, normalise column names and convert to sf
occ |>
  select(
    taxon, gbif_key = key, genus, species,
    longitude = decimalLongitude, latitude = decimalLatitude
  ) |>
  st_as_sf(coords = c("longitude", "latitude"), 
           crs = 4326, remove = FALSE) ->
  occ
```

```{r plot-occ-distribution}
ggplot(occ) + 
  facet_wrap(vars(taxon)) +
  layer_spatial(ne_land, fill = "#ffffff") +
  # annotation_spatial(s_levant, fill = alpha("red", 0.15), colour = "red") +
  layer_spatial(occ, alpha = 0.2) +
  # layer_spatial(ne_countries, fill = NA) +
  coord_sf(xlim = w_asia[c("xmin", "xmax")], 
           ylim = w_asia[c("ymin", "ymax")],
           crs = utm37n,
           default_crs = latlong)
```

<!-- TODO: following @ValaviEtAl2022, more accurate to call pseudo-absences
  "background samples" -->
Occurrence data only tells us where a species is present;
there is no definitive information on where the species is *not* found.
We therefore need to generate random background points or "pseudo-absences" to feed to the model.
There are several ways to do this. 
We follow the advice of Barbet-Massin et al. (2012) for regression-based species distribution models and use a large (~10000) random sample of points, weighted equally against the presences in the regression.
@ValaviEtAl2022 recommends using a very large background sample for random forest models.

```{r data-background}
# TODO: Make your mind up – what region are we modelling?
# Currently presence data is taken from across W Asia, but background is
#   generated only for the S. Levant.
# TODO: maybe defer this to just before the model is actually fit 
#   (and discard the background sample)
n_background <- 10000

occ |>
  mutate(present = TRUE) |>
  group_by(taxon) |>
  nest(.key = "occ_data") |>
  mutate(bg_data = map(1:n(), \(i) { 
    background_sample(
      region = s_levant_land, 
      N = n_background,
      coord_x = "longitude", coord_y = "latitude",
      present = FALSE
    )
  })) |>
  mutate(data = map2(occ_data, bg_data, bind_rows)) |>
  select(taxon, data) |>
  unnest(data) |>
  st_sf() ->
  occ
```

### Climate data

```{r data-climate}
raw_data("paleoclim") |>
  dir_ls() |>
  map(dir_ls, glob = "*.tif") |>
  map(read_stars) |>
  map(\(x) set_names(x, path_ext_remove(path_file(names(x))))) ->
  climate

# Tidy up names
names(climate) |>
  basename() |>
  str_remove(regex("chelsa_", ignore_case = TRUE)) |>
  str_split_i("_", 1) ->
  names(climate)
```

```{r training-climate}
occ <- cbind(occ, st_extract(climate$cur, occ)) |> select(-geometry.1)
```


### Other predictor data

Soil, terrain (incl. TWI, slope?)

### Random Forest

There are many methods for ENM.
Random Forest is one of the best performing, providing it is appropriately parameterised to account for the class imbalance between presence and background samples (balanced random forest) [@ValaviEtAl2021a; @ValaviEtAl2021b].

We used the R package ranger [@WrightZiegler2017].

```{r model}
rf_pred_vars <- function() {
  c(any_of("present"), starts_with("bio"))
}

# Drop any rows with NA values in any of the predictor variables
# TODO: Where do these actually come from? There's usually only a handful.
occ <- drop_na(occ, rf_pred_vars())

# Model
# Parameters adapted from the example of a down-sampled RF model given in
#   https://rvalavi.github.io/SDMwithRFs/#model-fitting-with-ranger-package
# TODO: tune?

rand_forest(mode = "classification", trees = 1000) |>
  set_engine(
    "ranger",
    probability = TRUE,
    sample.fraction = c(sum(as.logical(.y())) / n_background, 1)
  ) -> 
  rf_model 

# Fit to each taxon
occ |>
  nest(.by = taxon) |>
  mutate(
    data = map(data, as_tibble),
    fit = map(data, \(data) {
      fit(rf_model, factor(present) ~ ., data = select(data, rf_pred_vars()))
    })) ->
  rf_fits
```

## Results

### Modelled ecological niches

* On current data
* Sensitivity to climate fluctuations

### Hindcasting

```{r predict}
# TODO: tidy
# TODO: parallelise
rf_fit <- filter(rf_fits, taxon == "Secale cereale") |>
  pull(fit)[[1]]

# TODO: predict on all periods (maybe combine stars and collapse into dimension first?)
rf_pred_cur <- predict(climate$cur, rf_fit, type = "prob")
rf_pred_eh <- predict(climate$EH, rf_fit, type = "prob")
rf_pred_yds <- predict(climate$YDS, rf_fit, type = "prob")
rf_pred_ba <- predict(climate$BA, rf_fit, type = "prob")
rf_pred_hs1 <- predict(climate$HS1, rf_fit, type = "prob")
rf_pred_lgm <- predict(climate$LGM, rf_fit, type = "prob")

rf_pred <- c(rf_pred_cur, rf_pred_eh, rf_pred_yds, rf_pred_ba, rf_pred_hs1,
             rf_pred_lgm)
names(rf_pred) <- c("cur", "EH", "YDS", "BA", "HS1", "LGM")

ggplot() + 
  geom_stars(data = st_redimension(st_crop(rf_pred, w_asia))) + 
  facet_wrap(~new_dim)
```

### Verification

## Discussion
